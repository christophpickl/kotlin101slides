\sektion{Language Features}

\frame{\frametitle{We'll have a quick look at \ldots}
\begin{enumerate}
	\item Type inference
	\item Function declaration
	\item Lambdas
	\item Null handling
	\item Smart casts
	\item Properties
	\item Extension methods
	\item  Named \& default parameters
	\item Data classes
	\item Collection API
\end{enumerate}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Type inference}
\begin{lstlisting}
// mutable variable of type Int
var x = 42

// immutable value of type String
val y = "foobar"

// explicit type declaration
val z: Double = 13.37

// whatever the return type is
val z = someFunction()
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Function declaration}
\begin{lstlisting}
// global function with explicit return type
fun add1(x: Int, y: Int): Int {
  return x + y
}

// compact one-line syntax
fun add2(x: Int, y: Int) = x + y
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Class declaration}
\begin{lstlisting}
// single ctor is initializing its fields
class Greeter(private val prefix: String) {

  // string interpolation, no concatenation
  fun greet(name: String) =
    "$prefix ${name}!"
}
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{A simple application}
\begin{lstlisting}
fun main(args: Array<String>) {
  // no "new" keyword necessary
  val greeter = Greeter("Hello")

  // prints: "Hello sIT!"
  println(greeter.greet("sIT"))
}
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Lambdas compared}
\begin{lstlisting}
// java
Stream.of(1, 2, 3).filter(i -> i % 2 == 0)
  .collect(Collectors.toList());

// kotlin
listOf(1, 2, 3).filter { i -> i % 2 == 0 }
// or even shorter:
listOf(1, 2, 3).filter { it % 2 == 0 }
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Map function}
\begin{lstlisting}
fun <T, R> map(list: List<T>,
    transform: (T) -> R): List<R> {
  val result = arrayListOf<R>()
  for (item in list)
    result.add(transform(item))
  return result
}

// invoke the function and pass a lambda
map(listOf(1, 2, 3), { it -> it * 2 })
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Null handling}
\begin{lstlisting}
val maybe: String? = ...

maybe.length // COMPILE ERROR!!!

maybe?.length // type is Int?
maybe?.length ?: -1 // type is Int
maybe!!.length // i dont f*cking care!

if (maybe != null) {
  maybe.length // smart cast to String
}
\end{lstlisting}
\end{frame}


\fullimage{its_beautiful}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Smart casts}
\begin{columns}[t]
\begin{column}{0.5\textwidth}
\begin{center}
  Java
\end{center}
\begin{lstlisting}[style=twosided]
Object x = ...;
if (x instanceof A) {
  a = (A) x;
  a.foo();
} else if (x instanceof B) {
  B b = (B) x;
  b.bar();
} else {
  throw new Exception("Sad panda!");
}
\end{lstlisting}

\end{column}
\begin{column}{0.5\textwidth}
\begin{center}
  Kotlin
\end{center}
\begin{lstlisting}[style=twosided]
interface A { fun foo() }
interface B { fun bar() }
// ----------------------

val x: Any = ...
when (x) {
  is A -> x.foo()
  is B -> x.bar()
  else -> throw Exception("Sad panda!")
}
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile] \frametitle{Enum safety -- Java approach}
\begin{lstlisting}[basicstyle=\color{IJ_text}\ttfamily\tiny]
public enum SignMode {
  TAC {
    @Override public <T> T callback(Callback<T> callback) {
      return callback.onTac(); }},
  CARD_TAN {
    @Override public <T> T callback(Callback<T> callback) {
      return callback.onCardTan(); }},
  TAN {
    @Override public <T> T callback(Callback<T> callback) {
      return callback.onTan(); }};

  public abstract <T> T callback(Callback<T> callback);

  public interface Callback<T> {
    T onTac();
    T onCardTan();
    T onTan();
  }
}

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Enum safety -- compared}
\begin{columns}[t]
\begin{column}{0.5\textwidth}
\begin{center}
  Java
\end{center}
\begin{lstlisting}[style=twosided]
public int mode2int(SignMode mode) {
  return mode.callback(
  new Callback<Integer>() {
  @Override public Integer onTac() {
    return 1;
  }
  @Override public Integer onCardTan() {
    return 2;
  }
  @Override public Integer onTan() {
    return 3;
  }
  });
}
\end{lstlisting}
\end{column}
\begin{column}{0.5\textwidth}
\begin{center}
  Kotlin
\end{center}
\begin{lstlisting}[style=twosided]
enum class SignMode {
  TAC, CARD_TAN, TAN
}

fun mode2int(mode: SignMode) =
  when(mode) {
    SignMode.TAC -> 1
    SignMode.CARD_TAN -> 2
    SignMode.TAN -> 3
    // COMPILE ERROR if branch missing
  }
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile] \frametitle{Without Properties}
\begin{lstlisting}[basicstyle=\color{IJ_text}\ttfamily\tiny]
public class Account {
    
    private String id;
    private int amount;

    public Account(String id, int amount) {
        this.id = id;
        this.amount = amount;
    }

    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public int getAmount() {
        return amount;
    }
    public void setAmount(int amount) {
        this.amount = amount;
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile] \frametitle{With Properties}
\begin{lstlisting}
class Account {
  var id: String? = null
  var amount: Int = 0
}

// invoke getter/setter from java as usual
\end{lstlisting}
\end{frame}

\begin{frame}[fragile] \frametitle{Explicit Properties}
\begin{lstlisting}
class Account {
  // ... id ...
  var amount = 0
    get() = field // backing field
    set(value) {
      if (value < 0) throw SomeException()
        field = value
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile] \frametitle{Compact Properties}
\begin{lstlisting}
// primary ctor initializing properties
class Account(
  var id: String,
  var amount: Int
)
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Extension methods -- The Problem}
\begin{lstlisting}
String x = " abc ";

// we are used to call methods like this
x.length();

// but as String is final we do this:
StringUtil.trim(" abc ");

// how many StringUtils are out there?!
\end{lstlisting}
\end{frame}

\begin{frame}[fragile] \frametitle{Extension methods -- The Solution}
\begin{lstlisting}
fun String.trim(): String {
    // "this" refers to current string
    ...
}

" abc ".trim()
\end{lstlisting}
\end{frame}


\frame{\frametitle{Extension Methods}
\begin{itemize}
	\item Known from C\#, Smalltalk, Ruby (\textit{monkey patch}) and others
	\item Add methods to yet compiled (final) classes
	\item No syntactic \textbf{difference} between calling real vs extension
	\item Actually simply creates \textbf{static methods} in background
	\item Problem of \textbf{delocalization} solved, auto-completion works
\end{itemize}

\center{\textit{Extension methods certainly are not object-oriented!}}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Named \& default parameters}
\begin{lstlisting}
TODO
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Data classes}
\begin{columns}[t]
\begin{column}{0.5\textwidth}
\begin{center}
  Java
\end{center}
\begin{lstlisting}[style=twosided]
public class Person {
 private final String name;
 private final int age;
 public Person(String name, int age) {
  this.name = name;
  this.age = age;
 }
 public String getName() {
  return name;
 }
 public int getAge() {
  return age;
 }
 public boolean equals(Object other) {
  ...
 }
 public int hashCode() {
  ...
 }
 public String toString() {
  ...
 }
}
\end{lstlisting}

\end{column}
\begin{column}{0.5\textwidth}
\begin{center}
  Kotlin
\end{center}
\begin{lstlisting}[style=twosided]
data class Person(
 val name: String,
 val age: Int
)

// same as with lombok but better ;)

// primary ctor deals with getters
// and field initialisation

// generates equals/hashCode/toString
// and a copy function (no builders!)
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\frame{\frametitle{Collection API}
\begin{itemize}
	\item Mutable vs immutable collections
	\item create a map: \texttt{mapOf("a" to 1, "b" to 2)}
	\item accessing a map: \texttt{map["a"]}
\end{itemize}
}

\begin{frame}[fragile] \frametitle{Collection API Samples}
\begin{lstlisting}
TODO
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frame{\frametitle{Further Features}
\begin{itemize}
	\item Delegation
	\item String handling
	\item Sealed classes
	\item Pattern matching
	\item Reified generics
	\item Operator overloading
	\item \texttt{if}, \texttt{try} and \texttt{when} as expressions
	\item == as equals
	\item Rename imports
	\item Backticks for escaping
	\item \ldots and much much more \ldots
\end{itemize}
}