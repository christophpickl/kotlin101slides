\sektion{Language Features}

\frame{\frametitle{We'll have a quick look at \ldots}
\begin{enumerate}
	\item Type inference
	\item Declarations
	\item Lambdas
	\item Null handling
	\item Smart casts
	\item Properties
	\item Extension methods
	\item  Named \& default arguments
	\item Data classes
	\item Collection API
\end{enumerate}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Type inference}
\begin{lstlisting}
// mutable variable of type Int
var x = 42

// immutable value of type String
val y = "foobar"

// explicit type declaration
val z: Double = 13.37

// whatever the return type is
val z = someFunction()
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Function declaration}
\begin{lstlisting}
// global function with explicit return type
fun add1(x: Int, y: Int): Int {
  return x + y
}

// compact one-line syntax
fun add2(x: Int, y: Int) = x + y

// possiblity to mark it as an infix funct.
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Class declaration}
\begin{lstlisting}
// single ctor is initializing its fields
class Greeter(private val prefix: String) {

  // string interpolation, no concatenation
  fun greet(name: String) =
    "$prefix ${name}!"
}
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Object declaration}
\begin{lstlisting}
object ProperSingleton : SomeInterface {
  fun greet() { println("Hello singleton.") }
}

// looks like a nasty static invocation
ProperSingleton.greet()

// pass an (the!) instance reference
someMethod(ProperSingleton)
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{A simple application}
\begin{lstlisting}
fun main(args: Array<String>) {
  // no "new" keyword necessary
  val greeter = Greeter("Hello")

  // prints: "Hello sIT!"
  println(greeter.greet("sIT"))
}
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Lambdas compared}
\begin{lstlisting}
// java
Stream.of(1, 2, 3).filter(i -> i % 2 == 0)
  .collect(Collectors.toList());

// kotlin
listOf(1, 2, 3).filter { i -> i % 2 == 0 }
// or even shorter:
listOf(1, 2, 3).filter { it % 2 == 0 }
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Map function}
\begin{lstlisting}
fun <T, R> map(list: List<T>,
    transform: (T) -> R): List<R> {
  val result = arrayListOf<R>()
  for (item in list)
    result.add(transform(item))
  return result
}

// invoke the function and pass a lambda
map(listOf(1, 2, 3), { it -> it * 2 })
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{withoutheadline}
\frame{
\begin{figure}[h]
  \centering
  \includegraphics[height=8cm]{nullpointer}
\end{figure}
}
\end{withoutheadline}

\begin{frame}[fragile] \frametitle{Null handling}
\begin{lstlisting}
val maybe: String? = ...

maybe.length // COMPILE ERROR!!!

maybe?.length // type is Int?
maybe?.length ?: -1 // type is Int
maybe!!.length // i dont f*cking care!

if (maybe != null) {
  maybe.length // smart cast to String
}
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Smart casts}
\begin{columns}[t]
\begin{column}{0.5\textwidth}
\begin{center}
  Java
\end{center}
\begin{lstlisting}[style=twosided]
Object x = ...;
if (x instanceof A) {
  a = (A) x;
  a.foo();
} else if (x instanceof B) {
  B b = (B) x;
  b.bar();
} else {
  throw new Exception("Sad panda!");
}
\end{lstlisting}

\end{column}
\begin{column}{0.5\textwidth}
\begin{center}
  Kotlin
\end{center}
\begin{lstlisting}[style=twosided]
val x: Any = ...
when (x) {
  is A -> x.foo()
  is B -> x.bar()
  else -> throw Exception("Sad panda!")
}
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile] \frametitle{Enum safety -- Java approach}
\begin{lstlisting}[basicstyle=\color{IJ_text}\ttfamily\tiny]
public enum SignMode {
  TAC {
    @Override public <T> T callback(Callback<T> callback) {
      return callback.onTac(); }},
  CARD_TAN {
    @Override public <T> T callback(Callback<T> callback) {
      return callback.onCardTan(); }},
  TAN {
    @Override public <T> T callback(Callback<T> callback) {
      return callback.onTan(); }};

  public abstract <T> T callback(Callback<T> callback);

  public interface Callback<T> {
    T onTac();
    T onCardTan();
    T onTan();
  }
}

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Enum safety -- compared}
\begin{columns}[t]
\begin{column}{0.5\textwidth}
\begin{center}
  Java
\end{center}
\begin{lstlisting}[style=twosided]
public int mode2int(SignMode mode) {
  return mode.callback(
  new Callback<Integer>() {
  @Override public Integer onTac() {
    return 1;
  }
  @Override public Integer onCardTan() {
    return 2;
  }
  @Override public Integer onTan() {
    return 3;
  }
  });
}
\end{lstlisting}
\end{column}
\begin{column}{0.5\textwidth}
\begin{center}
  Kotlin
\end{center}
\begin{lstlisting}[style=twosided]
enum class SignMode {
  TAC, CARD_TAN, TAN
}

fun mode2int(mode: SignMode) =
  when(mode) {
    SignMode.TAC -> 1
    SignMode.CARD_TAN -> 2
    SignMode.TAN -> 3
    // COMPILE ERROR if branch missing
  }
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile] \frametitle{Without Properties}
\begin{lstlisting}[basicstyle=\color{IJ_text}\ttfamily\tiny]
public class Account {
    
    private String id;
    private int amount;

    public Account(String id, int amount) {
        this.id = id;
        this.amount = amount;
    }

    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public int getAmount() {
        return amount;
    }
    public void setAmount(int amount) {
        this.amount = amount;
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile] \frametitle{With Properties}
\begin{lstlisting}
class Account {
  var id: String? = null
  var amount: Int = 0
}

// invoke getter/setter from java as usual
\end{lstlisting}
\end{frame}

\begin{frame}[fragile] \frametitle{Explicit Properties}
\begin{lstlisting}
class Account {
  var amount = 0
    get() = field // backing field
    set(value) {
      if (value < 0) throw SomeException()
        field = value
    }
    // ...
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile] \frametitle{Compact Properties}
\begin{lstlisting}
// primary ctor initializing properties
class Account(
  var id: String,
  var amount: Int
)
// no need for curly braces
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Extension methods -- The Problem}
\begin{lstlisting}
String agent = "7";

// we are used to call methods like this:
agent.length();

// but as String is final we do this:
StringUtil.pad(agent, 3, "0");

// how many String/FileUtils are out there?!
\end{lstlisting}
\end{frame}

\begin{frame}[fragile] \frametitle{Extension methods -- The Solution}
\begin{lstlisting}
fun String.pad(length: Int,
    symbol: String): String {
  // "this" refers to current string
  ...
}
val agent = "7"
agent.pad(3, "0") // auto-completion FTW!!!

// nullable receiver transformation
fun Money?.toDTO() =
  if (this == null) null else MoneyDTO(this)
\end{lstlisting}
\end{frame}

\fullimage{its_beautiful}

\frame{\frametitle{Extension Methods}
\begin{itemize}
	\item Known from C\#, Smalltalk, Ruby and others
	\item Add methods to yet compiled (final) classes
	\item No syntactic \textbf{difference} between calling real vs extension
	\item Actually simply creates \textbf{static methods} in background
	\item Problem of \textbf{delocalization} solved, auto-completion works
\end{itemize}

\center{\textit{Extension methods certainly are not object-oriented!}}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Default arguments}
\begin{lstlisting}
fun greet(
    name: String,
    prefix: String = "Hello")
  = "$prefix, ${name}!"

greet("sIT") // => "Hello, sIT!"
greet("sIT", "Hi") => "Hi, sIT!"

// no more overloaded methods + delegation!
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Named arguments}
\begin{lstlisting}
fun greet(
    name: String,
    prefix: String = "Hello",
    suffix: String = "!")
  { ... }

// specify the argument name and
// skip the "prefix" param (use default)
greet(name = "sIT", suffix = ".")
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Data classes}
\begin{columns}[t]
\begin{column}{0.5\textwidth}
\begin{center}
  Java
\end{center}
\begin{lstlisting}[style=twosided]
public class Person {
 private final String name;
 private final int age;
 public Person(String name, int age) {
  this.name = name;
  this.age = age;
 }
 public String getName() {
  return name;
 }
 public int getAge() {
  return age;
 }
 public boolean equals(Object other) {
  ...
 }
 public int hashCode() {
  ...
 }
 public String toString() {
  ...
 }
}
\end{lstlisting}

\end{column}
\begin{column}{0.5\textwidth}
\begin{center}
  Kotlin
\end{center}
\begin{lstlisting}[style=twosided]
data class Person(
 val name: String,
 val age: Int
)

// same as with lombok but better ;)

// primary ctor deals with getters
// and field initialisation

// generates equals/hashCode/toString
// and a copy function (no builders!)
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\frame{\frametitle{Collection API}
\begin{itemize}
	\item Collections designed properly! (im/mutability as in Scala)
	\item Create a map: \texttt{mapOf("a" to 1, "b" to 2)}
	\item Access a map: \texttt{map["a"]}
	\item Many useful (functional) extension methods \ldots
\end{itemize}
}

\begin{frame}[fragile] \frametitle{Collection API Samples}
\begin{lstlisting}
// val list = listOf(1, 2, 3)
val list = mutableListOf(1, 2, 3)
list.add(42) // would not compile!
list.requireNoNulls()
list.first() // => 1
list.firstOrNull { it > 10 } ?: -1
if (list.none { it > 10 })
  println("no big ones")
list.toList() // returns immutable copy

mapOf(1 to "a", 2 to "b", 3 to "a")
  .values.distinct().toHashSet()

\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frame{\frametitle{Further Features}
\begin{itemize}
	\item Delegation
	\item String handling
	\item Sealed classes
	\item Pattern matching
	\item Reified generics
	\item Operator overloading
	\item \texttt{if}, \texttt{try} and \texttt{when} as expressions
	\item == as equals
	\item Rename imports
	\item Backticks for escaping
	\item \ldots and much much more \ldots
\end{itemize}
}